/* @flow */

declare module.exports: {
  // Public: Install document observer.
  //
  //   observe('.foo', {
  //     add(el) { console.log(el, 'was added to the document') }
  //     remove(el) { console.log(el, 'was removed from the document') }
  //   })
  //
  observe<T: Element>(
    selector: string,
    handlersInit: HandlersObject<T> | Function,
    klassOptional: ?Class<T>
  ): Observer<T>
}

// Valid observe handlers.
type HandlersObject<T: Element> = {|
  initialize?: InitializerCallback<T>,
  add?: AddCallback<T>,
  remove?: RemoveCallback<T>
|}

// Valid function type for observer add() callback.
//
//   add(el) { console.log(el, 'was added to the document') }
//
type AddCallback<T: Element> = (el: T) => void

// Valid function type for observer remove() callback.
//
//   remove(el) { console.log(el, 'was removed from the document') }
//
type RemoveCallback<T: Element> = (el: T) => void

// Valid function type for observer initialize() callback.
//
//   initialize(el) { console.log(el, 'was added to the document for the first time') }
//
type InitializerCallback<T: Element> = (el: T) => void | InitializerCallbacks<T>

// Callbacks may also be dynamicially defined in an initializer callback to create
// a closure around shared state.
//
//   initialize(el) {
//     let counter = 0
//     return {
//       add() { counter++ },
//       remove() { counter-- }
//     }
//   }
//
type InitializerCallbacks<T: Element> = {|
  add?: AddCallback<T>,
  remove?: RemoveCallback<T>
|}

// After installing an observer, an object is returned with a `stop()` function
// to clean up the observer.
type Observer<T: Element> = {|
  // const observer = observe('.foo', {})
  // observer.stop()
  stop: () => void
|}
